---
title: "<br><br>Análisis de datos Ómicos<br>Primera prueba de evaluación continua<br>"
author: "Maria P. Plaza"
date: "16/04/2020"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
require(knitr)
knitr::opts_chunk$set(comment = NA, prompt = TRUE, tidy = FALSE, 
               fig.width = 7, fig.height = 7,echo = TRUE, 
               message = FALSE, warning = FALSE, cache=FALSE)
Sys.setlocale("LC_TIME", "C")

```

```{r packages, eval=FALSE, message=FALSE, warning=FALSE, include=FALSE}
if (!requireNamespace("BiocManager", quietly = TRUE))
  install.packages("BiocManager")
BiocManager::install(version = "3.10")
Bioconductor version 3.10 (BiocManager 1.30.10), ?BiocManager::install for help
#Para instalar los paquetes específicos:
BiocManager :: install (c ("Biobase", "methods", "affy", "GEOquery", "simpleaffy", "arrayQualityMetrics","biocLite" ))
BiocManager :: install("pvca")
BiocManager :: install("genefilter")
BiocManager :: install("mas5")
BiocManager :: install("gcrma")
BiocManager :: install("plier")
BiocManager :: install("genefilter")
```

# Análisis de Microarrays

## 0. Abstract, con un resumen breve de no más de cinco líneas.

<div style="text-align: justify">

articulo

https://www.ncbi.nlm.nih.gov/pubmed/31344396

El ejemplo analizado consiste en unos datos descargables en el siguiente link:
https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE125975 

## 1.Introducción (cambiar)

Qué haremos para analizar estos datos:

 - preprocesar los datos sin procesar (resumir las mediciones de la sonda en una medición para cada sonda)
 - normalizar los datos de estos ocho chips
 - calcular llamadas ausentes / presentes que intentan etiquetar genes que están "expresados"
 - calcular las relaciones de expresión de genes entre dos tejidos diferentes
 - usar una prueba estadística común para identificar genes expresados diferencialmente
 - Marcar datos de baja intensidad (muy probablemente ruido de fondo)
 - agrupar un subconjunto expresado diferencialmente de todos los genes para identificar aquellos con perfiles de expresión similares
 - trate de encontrar qué funciones tienen en común grupos específicos de genes (con perfiles de expresión similares)

## 2. Objetivos: Que se pretende con este estudio

Se recogieron tejidos hepáticos recién congelados de 22 ratones (3 de control, 9 tratados con vehículo y 10 tratados con nintedanib), y se extrajo el ARN. El análisis del transcriptoma del genoma completo se obtuvo usando ene Chip HT MG-430 (Affymetrix) de acuerdo con los protocolos del fabricante.

El objetivo principal que se persigue con nuestro análisis de expresión genética en tumores de ratón es estimar el posible error de clasificación mediante expresión genética de nuevos casos.

Los objetivos específicos que se persiguen nos llevan a cubrir un análisis completo de
microarrays de expresión genética:

- Control de calidad de microarrays de expresión genética
- Pre procesado de microarrays
- Corrección del Background
- Normalización
- Sumarización
- Control de calidad de datos pre procesados
- Selección de genes diferenciados por expresión
- Clasificación y evaluación de tejidos tumorales por firmas genéticas


Es preciso especificar 
– Cual es el propósito del estudio 
– Que objetivos persigue 
– Que limitaciones y de que tipo presenta
Deben tomarse decisiones relativas a aspectos diversos implicados en el experimento 
– Tipos de muestras
• Mezcladas (“pooled”) o individuales
• Con réplicas independientes o sin ellas 
– Limitaciones físicas (coste)
• Número de arrays necesarios/posibles
• Cantidad de material necesaria/disponible
• De aquí saldrá 
– La forma en que se realizará el experimento 
– Los métodos estadísticos que debemos aplicar

Prepocesado(1): Control de calidad
Preposezado(2): Normalización

Analisis de datos:
Los investigadores suelen estar interesados en distintos tipos de cuestiones:.
– Encontrar genes diferencialmente expresados entre dos o más condiciones o a lo largo del tiempo.
– Identificar nuevos subtipos en una población
– Descubrir patrones de expresión característicos. 
– Predecir la respuesta al tratamiento or clasificar un nuevo individuo utilizando información molecular. 
– Identificar genes co-regulados o expresándose en la misma ruta metabólica.

Métodos de análisis
• Para cada problema existen múltiples métodos
– Modelos lineales, pruebas-t con shrinkage para estudios de expresión diferencial
– Distintos tipos de análisis de conglomerados (“clustering”) para descubrir patrones de corregulación
– Métodos de clasificación tradicionales (LDA, kNN) y modernos (SVM, PAM) para construir predictores
– Métodos de análisis basados en la GO (GSEA) para buscar significación biológica

Microarray Data analysis workflow
o Image analysis
o Raw data
o Diagnostic plots
o Normalization
o Filtering
o Estimate missing
values
o Differential gene
inference
! Linear modeling and
factorial experiment
o Clustering
o Classification
o Annotation
o GO analysis
o Pathway analysis

 *What’s Your Question?*
What are the targets genes for my knock-out gene?
Gene discovery, differential expression 

Is a specified group of genes (genes from a pathway) all up-regulated in a specified condition?
Gene set enrichment analysis 

Can I use the expression profile of cancer patients to predict chemotherapy outcome?
Class prediction, classification

Pathways/network affected?
Kegg, Biocarta
Considering Pathway/network Topology 

## 3. Materiales y Métodos

### 3. 1. Obtención y lectura de datos (Naturaleza de los datos, tipo de experimento, diseño experimental, tipo de microarrays utilizados,…)

https://www.ncbi.nlm.nih.gov/geo/browse/

El articulo escogido se denomina: *An Immune Gene Expression Signature Associated With Development of Human Hepatocellular Carcinoma Identifies Mice That Respond to Chemopreventive Agents*

https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE125975

**Base de datos**

Se trata de un estudio en el que se analizan los perfiles de expresión génica de tejidos hepáticos no tumorales de 392 pacientes con HCC (carcinoma hepatocelular) en estadio temprano (conjunto de entrenamiento, n = 167 y conjunto de validación, n = 225) y tejido hepático de pacientes con cirrosis sin HCC (n = 216, controles) para identificar cambios en la expresión de genes que regulan la respuesta inmune que podría contribuir a la hepatocarcinogénesis, con Microarrays Affymetrix de expresión genética.

El tipo de microarray es: HT_MG-430_PM (Affymetrix).[CDF: HTMG430PM_Mm_ENTREZG, Brainarray version 19]

La cantidad total de genes que contiene la base de datos es de 13392 genes en 22 muestras.

Los datos de expresión sin procesar de microarrays se normalizaron utilizando el algoritmo robusto de múltiples matrices (Irizarry RA et al, Nucleic Acids Res, 2003) con una definición de conjunto de sonda personalizada que mapeó las sondas a las ID de genes de Entrez (HTMG430PM_Mm_ENTREZG) (Dai M et al, Nucleic Acids Res, 2005).

Una vez pre procesados los datos, obtenemos el objeto exprdata de tipo ExpresionSet.

```{r}
# Para acceder a GEO Sample (GSM), GEO Series (GSE) (listas de archivos GSM que juntos forman un solo experimento) o GEO Dataset (GDS), empleamos la función getGEO()que devuelve una lista de ExpressionSets

library(GEOquery)
library(affy)
gset <- getGEO("GSE125975", GSEMatrix =TRUE, AnnotGPL=FALSE)
if (length(gset) > 1) idx <- grep("GPL21382", attr(gset, "names")) else idx <- 1
gset <- gset[[idx]]

# make proper column names to match toptable 
fvarLabels(gset) <- make.names(fvarLabels(gset))

dim(exprs(gset))
pheno.data <- pData(gset)

# tambien podemos obtener los datos RAW. descargando los datos directamente de la pagina a nuestra carpeta de trabajo, despues usamos affy pa leer los datos.

celpath <- "./GSE125975_RAW"
data.raw = ReadAffy(celfile.path=celpath)

# la getGEOSuppFiles() función creará un directorio dentro del directorio de trabajo actual para almacenar los datos sin procesar. Aquí, las rutas de los archivos descargados (a menudo con una extensión .tar) se almacenan en un marco de datos llamado filePaths.

#filePaths = getGEOSuppFiles("GSE125975")
#filePaths

```

Los datos concretos con los que vamos a trabajar los observamos en la siguiente tabla:

Platforms (1)	
GPL21382	[HT_MG-430_PM] Affymetrix HT MG-430 PM Array Plate [CDF: HTMG430PM_Mm_ENTREZG, Brainarray version 19]

Samples (22)
Less... Less...           
GSM3587187	QP-4 Control Vehicle
GSM3587188	QP-49 Control Vehicle
GSM3587189	QP-50 Control Vehicle
GSM3587190	QP-76 Model Vehicle
GSM3587191	QP-77 Model Vehicle
GSM3587192	QP-78 Model Vehicle
GSM3587193	QP-79 Model Vehicle
GSM3587194	QP-80 Model Vehicle
GSM3587195	QP-81 Model Vehicle
GSM3587196	QP-92 Model Vehicle
GSM3587197	QP-93 Model Vehicle
GSM3587198	QP-94 Model Vehicle
GSM3587199	QP-82 Model Nintedanib
GSM3587200	QP-83 Model Nintedanib
GSM3587201	QP-84 Model Nintedanib
GSM3587202	QP-85 Model Nintedanib
GSM3587203	QP-86 Model Nintedanib
GSM3587204	QP-87 Model Nintedanib
GSM3587205	QP-88 Model Nintedanib
GSM3587206	QP-89 Model Nintedanib
GSM3587207	QP-90 Model Nintedanib
GSM3587208	QP-91 Model Nintedanib

```{r}
gpl21382 <- getGEO('GPL21382')

Meta(gpl21382)$title
head(Meta(gpl21382)$series_id)
length(Meta(gpl21382)$series_id)
head(Meta(gpl21382)$sample_id)
length(Meta(gpl21382)$sample_id)

gsmids <- Meta(gpl21382)$sample_id
gsmlist <- sapply(gsmids[1:5],getGEO)
names(gsmlist)

citation("GEOquery")

```

### 3. Que habéis hecho en cada paso (NO ES PRECISO entrar en el detalle de los métodos,más bien hacer una descripción cualitativa indicando porque se ha llevado a cabo cada paso, y cual ha sido el “input” suministrado al procedimiento y el “output” obtenido.

## Exploración

En primer lugar debemos hacer una exploración de los datos con los que trabajamos. Para ello los representamos en varios tipos de graficos. 

*HISTOGRAM*

```{r}
library(reshape)
library(ggplot2)
exprs0 <- exprs(gset)
df = data.frame(gene = featureNames(gset),exprs0)
df1 = melt(df,id=c("gene"))
ggplot(df1,aes(x=value,colour=variable,group=variable)) +
geom_density(kernel = "epanechnikov",fill=NA) ## Estimadores densidad
```

Según la imagen anterior, algunas muestras discrepan de la media. Además la forma extraña que vemos a la derecha, en el value = 5, puede indicar un error sistemático.

*BOXPLOTS*

Podemos ademas representar las muestras en diagramas de cajas o Boxplots, mostrando la distribución de los niveles de expresión a lo largo de las muestras.
Como vemos, hay algunas que se desvían del comportamiento general:

```{r}
ggplot(df1,aes(x=variable,y = value)) + geom_boxplot() +
coord_flip()
```

*HIERARCHICAL CLUSTERING ANALYSIS*

Finalmente un cluster jerárquico seguido de un dendrograma nos puede ayudar a hacernos una idea de si las muestras se agrupan por condiciones experimentales

```{r}
dist.clust <- dist(t(exprs(gset)))
hclust (dist.clust, "average")
plot(hclust (dist.clust, "average"))

```

Estos gráficos nos has mostrado:

1. Hay al menos dos valores atípicos en el conjunto de datos
2. La distribución de las intensidades en cada matriz (boxplots) ilustra la necesidad de un paso de normalización.

También es posible visualizar la imagen que representa cada archivo CEL (en este ejemplo, visualizamos solo la primera diapositiva del conjunto de datos). De esta manera, es posible identificar problemas técnicos que ocurren eventualmente solo en una región de la matriz.

```{r}
image(exprs(gset))
```

## Control de calidad

La funcion *arrayQualityMetrics* produce un informe de métricas de calidad de nuestra matriz de datos, que guardamos dentro de nuestra carpeta de resultados:

```{r}
library(arrayQualityMetrics)
arrayQualityMetrics(data.raw, outdir = file.path("./results", "reportquality_dataRAW"))
```

y vemos los datos en un grafico PCA:

```{r}
library(ggplot2)
library(ggrepel)

# Creamos la funci'on necesaria
plotPCA <- function (datos, labels, factor, title, scale,colores, size = 1.5, glineas = 0.25) {
 data <- prcomp(t(datos),scale=scale)
 # plot adjustments
 dataDf <- data.frame(data$x)
 Group <- factor
 loads <- round(data$sdev^2/sum(data$sdev^2)*100,1)
 # main plot
 p1 <- ggplot(dataDf,aes(x=PC1, y=PC2)) +
   theme_classic() +
   geom_hline(yintercept = 0, color = "gray70") +
   geom_vline(xintercept = 0, color = "gray70") +
   geom_point(aes(color = Group), alpha = 0.55, size = 3) +
   coord_cartesian(xlim = c(min(data$x[,1])-5,max(data$x[,1])+5)) +
   scale_fill_discrete(name = "Group")
 # avoiding labels superposition
 p1 + geom_text_repel(aes(y = PC2 + 0.25, label = labels),segment.size = 0.25, size = size) + 
   labs(x = c(paste("PC1",loads[1],"%")),y=c(paste("PC2",loads[2],"%"))) +  
   ggtitle(paste("Principal Component Analysis for: ",title,sep=" "))+ 
   theme(plot.title = element_text(hjust = 0.5)) +
   scale_color_manual(values=colores)
}

# lo dibujamos
plotPCA(exprs(data.raw), labels = pheno.data$characteristics_ch1, factor = pheno.data$`treatment:ch1`, 
      title="Raw data", scale = FALSE, size = 3, 
      colores = c("red", "blue", "green", "yellow"))
```

## Normalización

La normalización supone la corrección de dos o más muestras antes de comparar sus valores de expresión. Suele constar de tres pasos:
! Corrección del fondo (background): Estimar y eliminar la intensidad de ruido de fondo
! Normalización global o local: Asegurar que la mayoría de las sondas varíen igual
! Sumarización: Conversión de sondas o conjuntos de sondas a transcritos o genes

Empleamos el Robust Multiarray Analysis: Método para realizar la corrección de fondo, normalización y sumarización en chips de Affymetrix. Tiene una precisión mucho mayor que MAS 5.0 (el método de Affymetrix para preprocesar sus chips). Además:
! Corrección de fondo sin contar MM
! Normalización por cuantiles
! Estimación por median polish

```{r}
eset_rma <- rma(data.raw)
```

Vemos la normalizaci'on con otro tipo de funciones:

```{r}
library(limma)
library(edgeR)

plotMDS(gset) #Esta funci'on grafica las muestras en un diagrama de dispersión bidimensional para que las distancias en el gráfico se aproximen a los cambios típicos de pliegue log2 entre las muestras.

calcNormFactors(gset) #Calcula los factores de normalización para escalar los datos.
```

```{r}
library(limma)
# La siguiente funcion normaliza las intensidades de expresión para que las intensidades o las proporciones logarítmicas tengan distribuciones similares en un conjunto de matrices
exprs1 = normalizeBetweenArrays(exprs(gset),method = "quantile") 
head(exprs1)

# O bien podemos hacer que coincidan las medianas de los distintos arrays con
exprs2 = normalizeBetweenArrays(exprs(gset),method = "scale")
head(exprs2)

```

## Control de calidad de datos normalizados

Empleamos de nuevo la funcion *arrayQualityMetrics* para producir un informe de métricas para combrobar la calidad de la matriz normalizada y guardamos la tabla creada en la carpeta de resultados.

```{r}
arrayQualityMetrics(eset_rma, outdir = file.path("./results", "QCraw.Norm"), force=TRUE)
```

*PCA y boxplot*

Visualización de los dos primeros componentes principales para datos normalizados.

```{r}
plotPCA(exprs(eset_rma), labels = pheno.data$characteristics_ch1, factor = pheno.data$`treatment:ch1`, 
        title="Normalized data", scale = FALSE, size = 3, 
        colores = c("red", "blue", "green", "yellow"))

```

Ahora el primer componente representa el 14.9% de la variabilidad total. El porcentaje de variabilidad explicada ha disminuido con respecto a la PCA realizada en datos sin procesar. Del mismo modo que con el PCA con datos sin procesar, separa las muestras del nivel FRÍO de la condición de temperatura a la derecha, y las muestras del nivel RT a la izquierda. Es importante tener en cuenta que hay una muestra del grupo KO.RT que agrupa cerca de WT.RT y viceversa. Podría ser un problema de etiquetado incorrecto de las muestras que deben verificarse con el laboratorio que ha procesado las muestras.

La figura siguiente figura muestra un diagrama de caja múltiple que representa la distribución de las intensidades normalizadas a lo largo de todas las muestras. Tenga en cuenta que todas las gráficas de caja tienen el mismo aspecto. Esto sugiere que la normalización ha funcionado bien. Sin embargo, es importante tener en cuenta que RMA incluye un paso ("normalización cuantil") donde la distribución empírica de todas las muestras se establece en los mismos valores. Como consecuencia, se espera que los diagramas de caja sean idénticos o al menos muy similares.

```{r}
exprs1 <- exprs(eset_rma)
df.norm = data.frame(gene = featureNames(eset_rma),exprs1)
df2 = melt(df.norm,id=c("gene"))

ggplot(df2,aes(x=variable,y = value)) + geom_boxplot() +
coord_flip()
```

```{r}
#heatmap
rsd <- apply(exprs(eset_rma), 1, sd)
sel <- order(rsd, decreasing = TRUE)[1:50]
heatmap(exprs(eset_rma)[sel, ])  
```

## Detectar genes más variables

La selección de genes expresados diferencialmente se ve afectada por la cantidad de genes en los que la hacemos. Cuanto mayor sea el número, mayor será el ajuste necesario de los valores de p (como se verá a continuación), lo que nos llevará a terminar abortando más genes.

Si un gen se expresa de manera diferencial, se espera que haya una cierta diferencia entre los grupos y, por lo tanto, la varianza general del gen será mayor que la de aquellos que no tienen expresión diferencial. Trazar la variabilidad general de todos los genes es útil para decidir qué porcentaje de genes muestra una variabilidad que puede atribuirse a otras causas que no sean la variación aleatoria. La siguiente figura representa las desviaciones estándar de todos los genes ordenados de menor a mayor valor. El gráfico muestra que los genes más variables son aquellos con una desviación estándar superior al 90-95% de todas las desviaciones estándar.

```{r}
sds <- apply (exprs(eset_rma), 1, sd)
sdsO<- sort(sds)
plot(1:length(sdsO), sdsO, main="Distribution of variability for all genes",
    sub="Vertical lines represent 90% and 95% percentiles",
    xlab="Gene index (from least to most variable)", ylab="Standard deviation")
abline(v=length(sds)*c(0.9,0.95))
```

La función "Mclust" del paquete mclust https://cran.r-project.org/web/packages/mclust/mclust.pdf se usa para aplicar el modelo de mezcla gaussiana a la matriz de expresión génica ingresada. Además, también se generan archivos que contienen información sobre la media, la varianza, la proporción de mezcla y la asignación gaussiana del conjunto de datos.

```{r}
# BiocManager :: install("mclust")
library(mclust) # Esta función devuelve un objeto que contiene el número de genes / sondas para seleccionar durante el proceso de selección de características.

mclustplot <- Mclust(eset_rma)
summary(mclustplot)
head(mclustplot)
plot(mclustplot)
```

## Algoritmos de selección de genes. Selección de genes expresados de forma diferencial

Una vez preprocesados, tenemos dos tipos de análisis sobre datos de microarrays
! Estadística inferencial: determinar qué genes están expresados diferencialmente (DEGs) y si dicha expresión es significativa
! Estadística descriptiva: determinar grupos de genes que presentan patrones similares con PCA y cluster.

```{r}

# Para acceder a GEO Sample (GSM), GEO Series (GSE) (listas de archivos GSM que juntos forman un solo experimento) o GEO Dataset (GDS), empleamos la función getGEO()que devuelve una lista de ExpressionSets

#   Differential expression analysis with limma
library(Biobase)
library(GEOquery)
library(limma)

# load series and platform data from GEO

gset <- getGEO("GSE125975", GSEMatrix =TRUE, AnnotGPL=FALSE)
if (length(gset) > 1) idx <- grep("GPL21382", attr(gset, "names")) else idx <- 1
gset <- gset[[idx]]

# make proper column names to match toptable 
fvarLabels(gset) <- make.names(fvarLabels(gset))

# group names for all samples
gsms <- "0000000000001111111111"
sml <- c()
for (i in 1:nchar(gsms)) { sml[i] <- substr(gsms,i,i) }

# log2 transform
exprs(gset) <- log2(exprs(gset))

# set up the data and proceed with analysis
sml <- paste("G", sml, sep="")    # set group names
fl <- as.factor(sml)
gset$description <- fl
design <- model.matrix(~ description + 0, gset)
colnames(design) <- levels(fl) #Defining the experimental setup: The design matrix
fit <- lmFit(gset, design) # Model estimation and gene selection
cont.matrix <- makeContrasts(G1-G0, levels=design) # contrastar
fit2 <- contrasts.fit(fit, cont.matrix) # Multiple comparisons
fit2 <- eBayes(fit2, 0.01) #Para ver los 10 primeros genes expresados diferencialmente, ordenados por el estadístico B, se utilizará la función topTable. 
summary(fit2)

# El paquete limma implementa la función topTable que contiene, para un contraste dado, una lista de genes ordenados del valor p más pequeño al más grande que puede considerarse como expresado de mayor a menor diferencial. Para cada gen se proporcionan las siguientes estadísticas:

tT <- topTable(fit2, adjust="fdr", sort.by="B", number=250)

tT <- subset(tT, select=c("ID","adj.P.Val","P.Value","t","B","logFC","SPOT_ID")) #Obtaining lists of differentially expressed genes
write.table(tT, file=stdout(), row.names=F, sep="\t")
write.csv(tT, file= "./results/data_analisys.csv", sep = ",")


################################################################
#   Boxplot for selected GEO samples
library(Biobase)
library(GEOquery)

# load series and platform data from GEO

gset <- getGEO("GSE125975", GSEMatrix =TRUE, getGPL=FALSE)
if (length(gset) > 1) idx <- grep("GPL21382", attr(gset, "names")) else idx <- 1
gset <- gset[[idx]]

# group names for all samples in a series
gsms <- "0000000000001111111111"
sml <- c()
for (i in 1:nchar(gsms)) { sml[i] <- substr(gsms,i,i) }
sml <- paste("G", sml, sep="")  # set group names

# order samples by group
ex <- exprs(gset)[ , order(sml)]
sml <- sml[order(sml)]
fl <- as.factor(sml)
labels <- c("Treat1_vehicle","Treat2_nintedanib")

# set parameters and draw the plot
palette(c("#f2cb98","#f4dfdf", "#AABBCC"))
dev.new(width=4+dim(gset)[[2]]/5, height=6)
par(mar=c(2+round(max(nchar(sampleNames(gset)))/2),4,2,1))
title <- paste ("GSE125975", '/', annotation(gset), " selected samples", sep ='')

boxplot(ex, boxwex=0.6, notch=T, main=title, outline=FALSE, las=2, col=fl)
legend("topleft", labels, fill=palette(), bty="n")

```

Si queremos obtener todos los genes cuyo p-valor < 0.05, primero debemos almacenar en una variable todos los genes ordenados por el estadístico B.

```{r}

tabla13392<- topTable(fit2,coef=1,number=13392,genelist=fit2$genes,adjust.method="BH",sort.by="B")

menores <- subset(tabla13392, P.Value < 0.005, c("ID","adj.P.Val","P.Value","t","B","logFC","SPOT_ID"))
menores[1,]

# Luego podemos observar visualmente el gen de mayor expresión diferencial de la siguiente forma:
M<- fit2$coefficients
A<- fit2$Amean
plot (A, M, pch=".", col="lightblue", cex=2, main="Valores de M ajustados por eBayes")
points(tabla13392$A[1], tabla13392$M[1], pch="*", col=2,cex=1);text(11.2,2.64,tabla13392[1,5])

```

# 14. Gene Annotation (cambiar)
```{r}
# Once we have the top table it is useful to provide additional information on the features that have been selected. This process is called “annotation” and essentially what it does is to look for information to associate identifiers that appear in the top table, usually corresponding to probesets or transcripts depending of the array type, with more familiar names such as the Gene Symbol, the Entrez Gene identifier or the Gene description.

# For simplicity, because there are three toptables, a function annotating one topTable with a given package is prepared and used.

annotatedTopTable <- function(topTab, anotPackage)
{
 topTab <- cbind(PROBEID=rownames(topTab), topTab)
 myProbes <- rownames(topTab)
 thePackage <- eval(parse(text = anotPackage))
 geneAnots <- select(thePackage, myProbes, c("SYMBOL", "ENTREZID", "GENENAME"))
 annotatedTopTab<- merge(x=geneAnots, y=topTab, by.x="PROBEID", by.y="PROBEID")
return(annotatedTopTab)
}

annotation(data.raw)

# cambiar a partir de aqui
topAnnotated_KOvsWT.COLD <- annotatedTopTable(topTab_KOvsWT.COLD,
anotPackage="htmg430pm")
topAnnotated_KOvsWT.RT <- annotatedTopTable(topTab_KOvsWT.RT,
anotPackage="htmg430pm")
topAnnotated_INT <- annotatedTopTable(topTab_INT,
anotPackage="htmg430pm")
write.csv(topAnnotated_KOvsWT.COLD, file="./results/topAnnotated_KOvsWT_COLD.csv")
write.csv(topAnnotated_KOvsWT.RT, file="./results/topAnnotated_KOvsWT_RT.csv")
write.csv(topAnnotated_INT, file="./results/topAnnotated_INT.csv")
```

# 15. Visualizing differential expression: VOlcano plot

```{r}
plot(fit2$coef, fit2$lods, pch = 16, cex = 0.2, xlab = "log2 (Fold change)", ylab = "-log10(P-Value)", main=paste("Differentially expressed genes"))
ord <- order(fit2$lods, decreasing = TRUE)
top8 <- ord[1:8]
text(fit2$coef[top8], fit2$lods[top8], labels = fit2$genes[top8,
"Name"], cex = 0.8, col = "blue")


```

Podemos ardem'as representar los valores normalizados con log2, con un gr'afico PCA:

```{r}
pheno.data <- pData(gset)
exp_raw <- log2(Biobase::exprs(gset))
PCA_raw <- prcomp(t(exp_raw), scale. = FALSE)

percentVar <- round(100*PCA_raw$sdev^2/sum(PCA_raw$sdev^2),1)
sd_ratio <- sqrt(percentVar[2] / percentVar[1])

dataGG <- data.frame(PC1 = PCA_raw$x[,1], PC2 = PCA_raw$x[,2],
Disease = pheno.data$characteristics_ch1,
Phenotype = pheno.data$`treatment:ch1`,
Individual = pheno.data$`treatment:ch1`)

ggplot(dataGG, aes(PC1, PC2)) +
geom_point(aes(shape = Disease, colour = Phenotype)) +
ggtitle("PCA plot of the log-transformed raw expression data") +
xlab(paste0("PC1, VarExp: ", percentVar[1], "%")) +
ylab(paste0("PC2, VarExp: ", percentVar[2], "%")) +
theme(plot.title = element_text(hjust = 0.5))+
coord_fixed(ratio = sd_ratio) +
scale_shape_manual(values = c(4,15)) + 
scale_color_manual(values = c("darkorange2", "dodgerblue4"))

```



# 18. Biological Significance of results

Una vez que se obtiene una lista de genes que caracteriza la diferencia entre dos condiciones, debe interpretarse. Aunque esto requiere, por supuesto, una buena comprensión del problema biológico subyacente, un enfoque estadístico conocido como "Análisis de conjunto de genes" puede ser útil para sugerir ideas para la interpretación.

Con este objetivo, estos tipos de análisis buscan establecer si, dada una lista de genes seleccionados por ser diferencial expresada entre dos condiciones, las funciones, procesos biológicos o vías moleculares que los caracterizan aparecen en esta lista con más frecuencia que entre el resto de los genes analizado.

Hay muchas variantes de estos tipos de análisis, ver Khatri, Sirota y Butte (2012), pero aquí usaremos el análisis de enriquecimiento básico como se describe en implementado en el paquete ReactomePA Bioconductor. El análisis se realiza en la base de datos de anotaciones ReactomePA https://reactome.org/.

Los análisis de este tipo necesitan un número mínimo de genes para ser confiables, preferiblemente unos pocos cientos que unas pocas docenas, por lo que es común realizar una selección menos restrictiva que con los pasos anteriores. Por ejemplo, una opción es incluir todos los genes con un límite de FDR no estricto, como FDR <0.15 sin filtrado por "cambio de pliegue" mínimo).

Como primer paso, preparamos la lista de listas de genes que se analizarán:


# 19. Resumen de resultados

Una vez que el proceso se ha completado, se obtiene una lista de archivos, a veces larga, con los datos y los resultados del análisis. Estos archivos son la base para discutir los resultados y buscar una interpretación biológica. Ambos aspectos exceden los objetivos de este capítulo, por lo que se omiten aquí.

Es útil crear un archivo con el tipo, nombre y descripción de todos los archivos generados a lo largo del análisis. La tabla @ref (tab: listOfFiles) muestra la lista de archivos generados en el estudio de caso actual.

## 4. Resultados
Que se obtiene como resultado del análisis

## 5. Discusión
Que limitaciones consideramos que pueden haber en el estudio (si consideramos
que hay alguna…)

## 6. Conclusión: NO HACE FALTA. Vuestro “rol” aquí es técnico. 
Como bioinformáticos se os presupondrá la capacidad de manejar la información biológica mediante los programas adecuados, pero ello no implica que debáis tener los conocimientos específicos que puede requerir la interpretación biológica de los resultados.

## 7. Apéndice: 
Podéis poner el código de R que hayáis utilizado en un apéndice con comentarios.

<div/>
